<stdin> : Type :=
  let Category : Type :=
    {
      Ob : Type;
      Hom : fun (_ : { S : Ob; T : Ob }) -> Type;
      id : fun (A : Ob) -> Hom { S := A; T := A };
      seq :
        fun (A : Ob) (B : Ob) (C : Ob) (_ : Hom { S := A; T := B })
            (_ : Hom { S := B; T := C }) -> Hom { S := A; T := C }
    };
  let Functor : Type :=
    {
      S : Category;
      T : Category;
      Map : fun (_ : S.Ob) -> T.Ob;
      map :
        fun (A : S.Ob) (B : S.Ob) (_ : S.Hom { S := A; T := B })
            -> T.Hom { S := Map A; T := Map B }
    };
  let Endofunctor : fun (C : Category) -> Type :=
    fun C => {
      S :
        {
          Ob : Type;
          Hom : fun (_ : { S : Ob; T : Ob }) -> Type;
          id : fun (A : Ob) -> Hom { S := A; T := A };
          seq :
            fun (A : Ob) (B : Ob) (C : Ob) (_ : Hom { S := A; T := B })
                (_ : Hom { S := B; T := C }) -> Hom { S := A; T := C }
        } [= C];
      T :
        {
          Ob : Type;
          Hom : fun (_ : { S : Ob; T : Ob }) -> Type;
          id : fun (A : Ob) -> Hom { S := A; T := A };
          seq :
            fun (A : Ob) (B : Ob) (C : Ob) (_ : Hom { S := A; T := B })
                (_ : Hom { S := B; T := C }) -> Hom { S := A; T := C }
        } [= C];
      Map : fun (_ : C.Ob) -> C.Ob;
      map :
        fun (A : C.Ob) (B : C.Ob) (_ : C.Hom { S := A; T := B })
            -> C.Hom { S := Map A; T := Map B }
    };
  let Monad : Type :=
    {
      C : Category;
      F : Endofunctor C;
      pure : fun (A : C.Ob) -> C.Hom { S := A; T := F.Map A };
      flatten :
        fun (A : C.Ob) -> C.Hom { S := F.Map (F.Map A); T := F.Map A };
      flat-map :
        fun (A : C.Ob) (B : C.Ob) (_ : C.Hom { S := A; T := F.Map B })
            -> C.Hom { S := F.Map A; T := F.Map B }
    };
  let op-category : fun (c : Category) -> Category :=
    fun c => {
      Ob := c.Ob;
      Hom := fun params => c.Hom { S := params.T; T := params.S };
      id := c.id;
      seq := fun A B C f g => c.seq C B A g f
    };
  let op-functor : fun (f : Functor) -> Functor :=
    fun f => {
      S := op-category f.S;
      T := op-category f.T;
      Map := f.Map;
      map := fun A B => f.map B A
    };
  let id-functor : fun (c : Category) -> Endofunctor c :=
    fun c => {
      S := #sing-intro;
      T := #sing-intro;
      Map := fun A => A;
      map := fun A B f => f
    };
  let seq-functor :
        fun (f1 : Functor)
            (f2 :
              {
                S :
                  {
                    Ob : Type;
                    Hom : fun (_ : { S : Ob; T : Ob }) -> Type;
                    id : fun (A : Ob) -> Hom { S := A; T := A };
                    seq :
                      fun (A : Ob) (B : Ob) (C : Ob)
                          (_ : Hom { S := A; T := B })
                          (_ : Hom { S := B; T := C })
                          -> Hom { S := A; T := C }
                  } [= f1.T];
                T :
                  {
                    Ob : Type;
                    Hom : fun (_ : { S : Ob; T : Ob }) -> Type;
                    id : fun (A : Ob) -> Hom { S := A; T := A };
                    seq :
                      fun (A : Ob) (B : Ob) (C : Ob)
                          (_ : Hom { S := A; T := B })
                          (_ : Hom { S := B; T := C })
                          -> Hom { S := A; T := C }
                  };
                Map : fun (_ : f1.T.Ob) -> T.Ob;
                map :
                  fun (A : f1.T.Ob) (B : f1.T.Ob)
                      (_ : f1.T.Hom { S := A; T := B })
                      -> T.Hom { S := Map A; T := Map B }
              })
            -> Functor
  :=
    fun f1 f2 => {
      S := f1.S;
      T := f2.T;
      Map := fun A => f2.Map (f1.Map A);
      map := fun A B f => f2.map (f1.Map A) (f1.Map B) (f1.map A B f)
    };
  let types : Category :=
    {
      Ob := Type;
      Hom := fun params => fun (_ : params.S) -> params.T;
      id := fun A a => a;
      seq := fun A B C f g a => g (f a)
    };
  let Option : fun (A : Type) -> Type :=
    fun A =>
      fun (Out : Type) (_ : { some : fun (_ : A) -> Out; none : Out }) -> Out;
  let none : fun (A : Type) -> Option A := fun A Out cases => cases.none;
  let some : fun (A : Type) (a : A) -> Option A :=
    fun A a Out cases => cases.some a;
  let option-functor : Endofunctor types :=
    {
      S := #sing-intro;
      T := #sing-intro;
      Map := Option;
      map :=
        fun A B f opt-A =>
          opt-A (Option B) { some := fun x => some B (f x); none := none B }
    };
  let option-monad : Monad :=
    {
      C := types;
      F := option-functor;
      pure := some;
      flatten :=
        fun A opt-opt-A =>
          opt-opt-A (Option A) { some := fun opt-A => opt-A; none := none A };
      flat-map :=
        fun A B f opt-A => opt-A (Option B) { some := f; none := none B }
    };
  let reader-functor : fun (Arg : Type) -> Endofunctor types :=
    fun Arg => {
      S := #sing-intro;
      T := #sing-intro;
      Map := fun A => fun (_ : Arg) -> A;
      map := fun A B f g => types.seq Arg A B g f
    };
  let reader-monad : fun (Arg : Type) -> Monad :=
    fun Arg => {
      C := types;
      F := reader-functor Arg;
      pure := fun A x arg => x;
      flatten := fun A f arg => f arg arg;
      flat-map := fun A B f g arg => f (g arg) arg
    };
  Type
