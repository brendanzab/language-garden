<stdin> : Type :=
  let Category : Type :=
    {
      Object : Type;
      Arrow : fun (_ : Object) (_ : Object) -> Type;
      id : fun (A : Object) -> Arrow A A;
      seq :
        fun (A : Object) (B : Object) (C : Object) (_ : Arrow A B)
            (_ : Arrow B C) -> Arrow A C
    };
  let Functor : Type :=
    {
      S : Category;
      T : Category;
      Map : fun (_ : S.Object) -> T.Object;
      map :
        fun (A : S.Object) (B : S.Object) (_ : S.Arrow A B)
            -> T.Arrow (Map A) (Map B)
    };
  let Endofunctor : fun (C : Category) -> Type :=
    fun C => {
      S :
        {
          Object : Type;
          Arrow : fun (_ : Object) (_ : Object) -> Type;
          id : fun (A : Object) -> Arrow A A;
          seq :
            fun (A : Object) (B : Object) (C : Object) (_ : Arrow A B)
                (_ : Arrow B C) -> Arrow A C
        } [= C];
      T :
        {
          Object : Type;
          Arrow : fun (_ : Object) (_ : Object) -> Type;
          id : fun (A : Object) -> Arrow A A;
          seq :
            fun (A : Object) (B : Object) (C : Object) (_ : Arrow A B)
                (_ : Arrow B C) -> Arrow A C
        } [= C];
      Map : fun (_ : C.Object) -> C.Object;
      map :
        fun (A : C.Object) (B : C.Object) (_ : C.Arrow A B)
            -> C.Arrow (Map A) (Map B)
    };
  let Monad : Type :=
    {
      C : Category;
      F : Endofunctor C;
      pure : fun (A : C.Object) -> C.Arrow A (F.Map A);
      flatten : fun (A : C.Object) -> C.Arrow (F.Map (F.Map A)) (F.Map A);
      flat-map :
        fun (A : C.Object) (B : C.Object) (_ : C.Arrow A (F.Map B))
            -> C.Arrow (F.Map A) (F.Map B)
    };
  let op-category : fun (c : Category) -> Category :=
    fun c => {
      Object := c.Object;
      Arrow := fun A B => c.Arrow B A;
      id := c.id;
      seq := fun A B C f g => c.seq C B A g f
    };
  let op-functor : fun (f : Functor) -> Functor :=
    fun f => {
      S := op-category f.S;
      T := op-category f.T;
      Map := f.Map;
      map := fun A B => f.map B A
    };
  let id-functor : fun (c : Category) -> Endofunctor c :=
    fun c => {
      S := #sing-intro;
      T := #sing-intro;
      Map := fun A => A;
      map := fun A B f => f
    };
  let seq-functor :
        fun (f1 : Functor)
            (f2 :
              {
                S :
                  {
                    Object : Type;
                    Arrow : fun (_ : Object) (_ : Object) -> Type;
                    id : fun (A : Object) -> Arrow A A;
                    seq :
                      fun (A : Object) (B : Object) (C : Object)
                          (_ : Arrow A B) (_ : Arrow B C) -> Arrow A C
                  } [= f1.T];
                T :
                  {
                    Object : Type;
                    Arrow : fun (_ : Object) (_ : Object) -> Type;
                    id : fun (A : Object) -> Arrow A A;
                    seq :
                      fun (A : Object) (B : Object) (C : Object)
                          (_ : Arrow A B) (_ : Arrow B C) -> Arrow A C
                  };
                Map : fun (_ : f1.T.Object) -> T.Object;
                map :
                  fun (A : f1.T.Object) (B : f1.T.Object)
                      (_ : f1.T.Arrow A B) -> T.Arrow (Map A) (Map B)
              })
            -> Functor
  :=
    fun f1 f2 => {
      S := f1.S;
      T := f2.T;
      Map := fun A => f2.Map (f1.Map A);
      map := fun A B f => f2.map (f1.Map A) (f1.Map B) (f1.map A B f)
    };
  let types : Category :=
    {
      Object := Type;
      Arrow := fun A B => fun (_ : A) -> B;
      id := fun A a => a;
      seq := fun A B C f g a => g (f a)
    };
  let Option : fun (A : Type) -> Type :=
    fun A =>
      fun (Out : Type) (_ : { some : fun (_ : A) -> Out; none : Out }) -> Out;
  let none : fun (A : Type) -> Option A := fun A Out cases => cases.none;
  let some : fun (A : Type) (a : A) -> Option A :=
    fun A a Out cases => cases.some a;
  let option-functor : Endofunctor types :=
    {
      S := #sing-intro;
      T := #sing-intro;
      Map := Option;
      map :=
        fun A B f opt-A =>
          opt-A (Option B) { some := fun x => some B (f x); none := none B }
    };
  let option-monad : Monad :=
    {
      C := types;
      F := option-functor;
      pure := some;
      flatten :=
        fun A opt-opt =>
          opt-opt (Option A) { some := fun opt => opt; none := none A };
      flat-map :=
        fun A B f opt =>
          opt (Option B) { some := fun x => f x; none := none B }
    };
  let reader-functor : fun (Arg : Type) -> Endofunctor types :=
    fun Arg => {
      S := #sing-intro;
      T := #sing-intro;
      Map := fun A => fun (_ : Arg) -> A;
      map := fun A B f g => types.seq Arg A B g f
    };
  let reader-monad : fun (Arg : Type) -> Monad :=
    fun Arg => {
      C := types;
      F := reader-functor Arg;
      pure := fun A x arg => x;
      flatten := fun A f arg => f arg arg;
      flat-map := fun A B f g arg => f (g arg) arg
    };
  Type
