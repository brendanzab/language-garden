-- A small category theory library
--
-- This provides `Functor` and `Monad` interfaces that are polymorphic over
-- their underlying categories, which is closer to the actual category theoretic
-- definitions, compared to the definitions in functional programming languages
-- like Haskell.

-- Generalisation of the theory of sets and functions
let Category := {
  Ob : Type;
  Hom : { S : Ob; T : Ob } -> Type;

  -- TODO: requires total space conversion like in CoolTT
  -- id : fun (A : Ob) -> Hom [ S := A; T := A ];
  -- seq : fun (f : Hom) (g : Hom [ S := f.T ]) -> Hom [ S := f.S; T := g.T ];

  -- The identity morphism
  id : fun (A : Ob) -> Hom { S := A; T := A };

  -- Sequencing morphisms (backwards composition)
  seq : fun (A : Ob) (B : Ob) (C : Ob) ->
    Hom { S := A; T := B } ->
    Hom { S := B; T := C } ->
    Hom { S := A; T := C };
};

-- Mapping between categories (i.e. a generalisation of functions between sets)
--
-- Contrast this definition with the `Functor` interface in the `control.txt`
-- example, which is actually an endofunctor in the category of types and
-- functions.
let Functor := {
  S : Category;   -- The source category
  T : Category;   -- The target category

  -- A mapping between objects in the source and target categories
  Map : S.Ob -> T.Ob;

  -- TODO: requires total space conversion like in CoolTT
  -- map : fun (f : Hom) -> Hom [ S := Map f.S; T := f.T ];

  -- A mapping between homomorphisms in the source and target categories
  map : fun (A : S.Ob) (B : S.Ob) ->
    S.Hom { S := A; T := B } ->
    T.Hom { S := Map A; T := Map B };
};

-- Mapping from a category to itself
let Endofunctor (C : Category) :=
  Functor [ S := C; T := C ];

let Monad := {
  C : Category;
  F : Endofunctor C;

  pure : fun (A : C.Ob) ->
    C.Hom { S := A; T := F.Map A };

  flatten : fun (A : C.Ob) ->
    C.Hom { S := F.Map (F.Map A); T := F.Map A };

  flat-map : fun (A : C.Ob) (B : C.Ob) ->
    C.Hom { S := A; T := F.Map B } ->
    C.Hom { S := F.Map A; T := F.Map B };
};


-- Opposites

let op-category (c : Category) : Category := {
  Ob := c.Ob;
  Hom params := c.Hom { S := params.T; T := params.S };
  id := c.id;
  seq A B C f g := c.seq C B A g f;
};

let op-functor (f : Functor) : Functor := {
  S := op-category f.S;
  T := op-category f.T;
  Map := f.Map;
  map A B := f.map B A;
};


-- Identity functor

let id-functor (c : Category) : Endofunctor c := {
  Map A := A;
  map A B f := f;
};


-- Composition of functors

let seq-functor (f1 : Functor) (f2 : Functor [ S := f1.T ]) : Functor := {
  S := f1.S;
  T := f2.T;
  Map A := f2.Map (f1.Map A);
  map A B f := f2.map (f1.Map A) (f1.Map B) (f1.map A B f);
};


-- Types and functions

-- Category of types and functions
let types : Category := {
  Ob := Type;
  Hom params := params.S -> params.T;
  id A a := a;
  seq A B C f g a := g (f a);
};


-- Optional values

let Option (A : Type) : Type :=
  fun (Out : Type) -> { some : A -> Out; none : Out } -> Out;

let none (A : Type) : Option A :=
  fun Out cases => cases.none;
let some (A : Type) (a : A) : Option A :=
  fun Out cases => cases.some a;

let option-functor : Endofunctor types := {
  Map := Option;
  map A B f opt-A :=
    opt-A (Option B) {
      some x := some B (f x);
      none := none B;
    };
};

let option-monad : Monad := {
  C := types;
  F := option-functor;

  pure := some;
  flatten A opt-opt-A :=
    opt-opt-A (Option A) {
      some opt-A := opt-A;
      none := none A;
    };
  flat-map A B f opt-A :=
    opt-A (Option B) {
      some := f;
      none := none B;
    };
};


-- Reader functor and monad

let reader-functor (Arg : Type) : Endofunctor types := {
  Map A := Arg -> A;
  map A B (f : A -> B) (g : Arg -> A) :=
    types.seq Arg A B g f;
};

let reader-monad (Arg : Type) : Monad := {
  C := types;
  F := reader-functor Arg;

  pure A x := fun arg => x;
  flatten A f := fun arg => f arg arg;
  flat-map A B f g := fun arg => f (g arg) arg;
};


Type
