-- A small category theory library
--
-- This provides `Functor` and `Monad` interfaces that are polymorphic over
-- their underlying categories, which is closer to the actual category theoretic
-- definitions, compared to the definitions in functional programming languages
-- like Haskell.
--
-- # Resources
--
-- * https://1lab.dev/Cat.Base.html
-- * https://hackage.haskell.org/package/category


--------------------------------------------------------------------------------
-- Categories
--------------------------------------------------------------------------------

-- Interface that provides a generalisation of the theory of sets and functions
let Category := {
  -- Collection of elements in the category
  Object : Type;

  -- Directional relationship between objects (a.k.a. homomorphisms)
  Arrow : Object -> Object -> Type;

  -- The identity arrow, that does nothing
  id : fun (A : Object) -> Arrow A A;

  -- Connecting morphisms one after the other (a.k.a. backwards composition)
  seq : fun (A : Object) (B : Object) (C : Object) ->
    Arrow A B -> Arrow B C -> Arrow A C;

  -- TODO: requires total space conversion like in CoolTT
  -- Arrow : { S : Object; T : Object } -> Type;
  -- id : fun (A : Object) -> Arrow [ S := A; T := A ];
  -- seq : fun (f : Arrow) (g : Arrow [ S := f.T ]) -> Arrow [ S := f.S; T := g.T ];
};

-- Opposite category
let op-category (c : Category) : Category := {
  Object := c.Object;
  Arrow A B := c.Arrow B A;
  id := c.id;
  seq A B C f g := c.seq C B A g f;
};

-- Category of types and functions
let types : Category := {
  Object := Type;
  Arrow A B := A -> B;
  id A a := a;
  seq A B C f g a := g (f a);
};


--------------------------------------------------------------------------------
-- Functors
--------------------------------------------------------------------------------

-- Mapping between categories (i.e. a generalisation of functions between sets)
--
-- Contrast this definition with the `Functor` interface in the `control.txt`
-- example, which is actually an endofunctor in the category of types and
-- functions.
let Functor := {
  src : Category;   -- The source category
  tgt : Category;   -- The target category

  -- A mapping between objects in the source and target categories
  Map : src.Object -> tgt.Object;

  -- A mapping between homomorphisms in the source and target categories
  map : fun (A : src.Object) (B : src.Object) ->
    src.Arrow A B ->
    tgt.Arrow (Map A) (Map B);

  -- TODO: requires total space conversion like in CoolTT
  -- map : fun (f : Arrow) -> Arrow [ S := Map f.S; T := f.T ];
};

-- Mapping from a category to itself
let Endofunctor (c : Category) :=
  Functor [ src := c; tgt := c ];

-- Opposite functor
let op-functor (f : Functor) : Functor := {
  src := op-category f.src;
  tgt := op-category f.tgt;
  Map := f.Map;
  map A B := f.map B A;
};

-- Identity functor
let id-functor (c : Category) : Endofunctor c := {
  Map A := A;
  map A B f := f;
};

-- Composition of functors
let seq-functor (f1 : Functor) (f2 : Functor [ src := f1.tgt ]) : Functor := {
  src := f1.src;
  tgt := f2.tgt;
  Map A := f2.Map (f1.Map A);
  map A B f := f2.map (f1.Map A) (f1.Map B) (f1.map A B f);
};


--------------------------------------------------------------------------------
-- Monads
--------------------------------------------------------------------------------

let Monad := {
  c : Category;
  f : Endofunctor c;

  pure : fun (A : c.Object) -> c.Arrow A (f.Map A);

  flatten : fun (A : c.Object) ->
    c.Arrow (f.Map (f.Map A)) (f.Map A);

  flat-map : fun (A : c.Object) (B : c.Object) ->
    c.Arrow A (f.Map B) ->
    c.Arrow (f.Map A) (f.Map B);
};


--------------------------------------------------------------------------------
-- Optional values
--------------------------------------------------------------------------------

let Option (A : Type) : Type :=
  fun (Out : Type) -> { some : A -> Out; none : Out } -> Out;

let none (A : Type) : Option A :=
  fun Out cases => cases.none;
let some (A : Type) (a : A) : Option A :=
  fun Out cases => cases.some a;

let option-functor : Endofunctor types := {
  Map := Option;
  map A B f opt-A :=
    opt-A (Option B) {
      some x := some B (f x);
      none := none B;
    };
};

let option-monad : Monad := {
  c := types;
  f := option-functor;

  pure := some;

  flatten A opt-opt :=
    opt-opt (Option A) {
      some opt := opt;
      none := none A;
    };

  flat-map A B f opt :=
    opt (Option B) {
      some x := f x;
      none := none B;
    };
};


--------------------------------------------------------------------------------
-- Reader functor and monad
--------------------------------------------------------------------------------

let reader-functor (Arg : Type) : Endofunctor types := {
  Map A := Arg -> A;
  map A B (f : A -> B) (g : Arg -> A) :=
    types.seq Arg A B g f;
};

let reader-monad (Arg : Type) : Monad := {
  c := types;
  f := reader-functor Arg;

  pure A x := fun arg => x;
  flatten A f := fun arg => f arg arg;
  flat-map A B f g := fun arg => f (g arg) arg;
};


Type
