-- A small category theory library
--
-- This provides `Functor` and `Monad` interfaces that are polymorphic over
-- their underlying categories, which is closer to the actual category theoretic
-- definitions, compared to the definitions in functional programming languages
-- like Haskell.
--
-- # Resources
--
-- * https://1lab.dev/Cat.Base.html
-- * https://hackage.haskell.org/package/category

-- Interface that provides a generalisation of the theory of sets and functions
let Category := {
  -- Collection of elements in the category
  Object : Type;

  -- Directional relationship between objects (a.k.a. homomorphisms)
  Arrow : { S : Object; T : Object } -> Type;

  -- TODO: requires total space conversion like in CoolTT
  -- id : fun (A : Object) -> Arrow [ S := A; T := A ];
  -- seq : fun (f : Arrow) (g : Arrow [ S := f.T ]) -> Arrow [ S := f.S; T := g.T ];

  -- The identity arrow, that does nothing
  id : fun (A : Object) -> Arrow { S := A; T := A };

  -- Connecting morphisms one after the other (a.k.a. backwards composition)
  seq : fun (A : Object) (B : Object) (C : Object) ->
    Arrow { S := A; T := B } ->
    Arrow { S := B; T := C } ->
    Arrow { S := A; T := C };
};

-- Mapping between categories (i.e. a generalisation of functions between sets)
--
-- Contrast this definition with the `Functor` interface in the `control.txt`
-- example, which is actually an endofunctor in the category of types and
-- functions.
let Functor := {
  S : Category;   -- The source category
  T : Category;   -- The target category

  -- A mapping between objects in the source and target categories
  Map : S.Object -> T.Object;

  -- TODO: requires total space conversion like in CoolTT
  -- map : fun (f : Arrow) -> Arrow [ S := Map f.S; T := f.T ];

  -- A mapping between homomorphisms in the source and target categories
  map : fun (A : S.Object) (B : S.Object) ->
    S.Arrow { S := A; T := B } ->
    T.Arrow { S := Map A; T := Map B };
};

-- Mapping from a category to itself
let Endofunctor (C : Category) :=
  Functor [ S := C; T := C ];

let Monad := {
  C : Category;
  F : Endofunctor C;

  pure : fun (A : C.Object) ->
    C.Arrow { S := A; T := F.Map A };

  flatten : fun (A : C.Object) ->
    C.Arrow { S := F.Map (F.Map A); T := F.Map A };

  flat-map : fun (A : C.Object) (B : C.Object) ->
    C.Arrow { S := A; T := F.Map B } ->
    C.Arrow { S := F.Map A; T := F.Map B };
};


-- Opposites

let op-category (c : Category) : Category := {
  Object := c.Object;
  Arrow params := c.Arrow { S := params.T; T := params.S };
  id := c.id;
  seq A B C f g := c.seq C B A g f;
};

let op-functor (f : Functor) : Functor := {
  S := op-category f.S;
  T := op-category f.T;
  Map := f.Map;
  map A B := f.map B A;
};


-- Identity functor

let id-functor (c : Category) : Endofunctor c := {
  Map A := A;
  map A B f := f;
};


-- Composition of functors

let seq-functor (f1 : Functor) (f2 : Functor [ S := f1.T ]) : Functor := {
  S := f1.S;
  T := f2.T;
  Map A := f2.Map (f1.Map A);
  map A B f := f2.map (f1.Map A) (f1.Map B) (f1.map A B f);
};


-- Types and functions

-- Category of types and functions
let types : Category := {
  Object := Type;
  Arrow params := params.S -> params.T;
  id A a := a;
  seq A B C f g a := g (f a);
};


-- Optional values

let Option (A : Type) : Type :=
  fun (Out : Type) -> { some : A -> Out; none : Out } -> Out;

let none (A : Type) : Option A :=
  fun Out cases => cases.none;
let some (A : Type) (a : A) : Option A :=
  fun Out cases => cases.some a;

let option-functor : Endofunctor types := {
  Map := Option;
  map A B f opt-A :=
    opt-A (Option B) {
      some x := some B (f x);
      none := none B;
    };
};

let option-monad : Monad := {
  C := types;
  F := option-functor;

  pure := some;

  flatten A opt-opt :=
    opt-opt (Option A) {
      some opt := opt;
      none := none A;
    };

  flat-map A B f opt :=
    opt (Option B) {
      some x := f x;
      none := none B;
    };
};


-- Reader functor and monad

let reader-functor (Arg : Type) : Endofunctor types := {
  Map A := Arg -> A;
  map A B (f : A -> B) (g : Arg -> A) :=
    types.seq Arg A B g f;
};

let reader-monad (Arg : Type) : Monad := {
  C := types;
  F := reader-functor Arg;

  pure A x := fun arg => x;
  flatten A f := fun arg => f arg arg;
  flat-map A B f g := fun arg => f (g arg) arg;
};


Type
