<input> : Type :=
  let Functor :=
    {
      T : Type -> Type;
      map : fun (A : Type) (B : Type) A -> B -> T A -> T B
    };
  let Applicative :=
    {
      T : Type -> Type;
      functor :
        {
          T : (Type -> Type) [= T];
          map : fun (A : Type) (B : Type) A -> B -> T A -> T B
        };
      pure : fun (A : Type) A -> T A;
      apply : fun (A : Type) (B : Type) T (A -> B) -> T A -> T B
    };
  let Monad :=
    {
      T : Type -> Type;
      applicative :
        {
          T : (Type -> Type) [= T];
          functor :
            {
              T : (Type -> Type) [= T];
              map : fun (A : Type) (B : Type) A -> B -> T A -> T B
            };
          pure : fun (A : Type) A -> T A;
          apply : fun (A : Type) (B : Type) T (A -> B) -> T A -> T B
        };
      flat-map : fun (A : Type) (B : Type) A -> T B -> T A -> T B
    };
  let Option : Type -> Type :=
    fun A := fun (Out : Type) { some : A -> Out; none : Out } -> Out;
  let none : fun (A : Type) -> Option A := fun A Out cases := cases.none;
  let some : fun (A : Type) A -> Option A :=
    fun A a Out cases := cases.some a;
  let option-functor : Functor :=
    {
      T := Option;
      map :=
        fun A B f opt-A :=
          opt-A (Option B) { some := fun x := some B (f x); none := none B }
    };
  let option-applicative : Applicative :=
    {
      T := Option;
      functor := { T := #sing-intro; map := option-functor.map };
      pure := some;
      apply :=
        fun A B opt-f opt-A :=
          opt-f (Option B)
            {
              some := fun f := option-functor.map A B f opt-A;
              none := none B
            }
    };
  let option-monad : Monad :=
    {
      T := Option;
      applicative :=
        {
          T := #sing-intro;
          functor := option-applicative.functor;
          pure := option-applicative.pure;
          apply := option-applicative.apply
        };
      flat-map :=
        fun A B f opt-A := opt-A (Option B) { some := f; none := none B }
    };
  Type
