<input> : Type :=
  let Functor :=
    {
      T : fun (_ : Type) -> Type;
      map : fun (A : Type) (B : Type) (_ : fun (_ : A) -> B) (_ : T A) -> T B
    };
  let Applicative :=
    {
      T : fun (_ : Type) -> Type;
      functor :
        {
          T : (fun (_ : Type) -> Type) [= T];
          map :
            fun (A : Type) (B : Type) (_ : fun (_ : A) -> B) (_ : T A) -> T B
        };
      pure : fun (A : Type) (_ : A) -> T A;
      apply :
        fun (A : Type) (B : Type) (_ : T (fun (_ : A) -> B)) (_ : T A) -> T B
    };
  let Monad :=
    {
      T : fun (_ : Type) -> Type;
      applicative :
        {
          T : (fun (_ : Type) -> Type) [= T];
          functor :
            {
              T : (fun (_ : Type) -> Type) [= T];
              map :
                fun (A : Type) (B : Type) (_ : fun (_ : A) -> B) (_ : T A)
                    -> T B
            };
          pure : fun (A : Type) (_ : A) -> T A;
          apply :
            fun (A : Type) (B : Type) (_ : T (fun (_ : A) -> B)) (_ : T A)
                -> T B
        };
      flat-map :
        fun (A : Type) (B : Type) (_ : fun (_ : A) -> T B) (_ : T A) -> T B
    };
  let Option :=
    (fun A :=
       fun (Out : Type) (_ : { some : fun (_ : A) -> Out; none : Out })
           -> Out) :
      fun (_ : Type) -> Type;
  let none := (fun A Out cases := cases.none) : fun (A : Type) -> Option A;
  let some :=
    (fun A a Out cases := cases.some a) : fun (A : Type) (_ : A) -> Option A;
  let option-functor :=
    {
      T := Option;
      map :=
        fun A B f opt-A :=
          opt-A (Option B) { some := fun x := some B (f x); none := none B }
    } : Functor;
  let option-applicative :=
    {
      T := Option;
      functor := { T := #sing-intro; map := option-functor.map };
      pure := some;
      apply :=
        fun A B opt-f opt-A :=
          opt-f (Option B)
            {
              some := fun f := option-functor.map A B f opt-A;
              none := none B
            }
    } : Applicative;
  let option-monad :=
    {
      T := Option;
      applicative :=
        {
          T := #sing-intro;
          functor := option-applicative.functor;
          pure := option-applicative.pure;
          apply := option-applicative.apply
        };
      flat-map :=
        fun A B f opt-A := opt-A (Option B) { some := f; none := none B }
    } : Monad;
  Type
