<stdin> : Type :=
  let Bool : Type :=
    fun (Out : Type) (_ : { true : Out; false : Out }) -> Out;
  let true : Bool :=
    fun (Out : Type) (cases : { true : Out; false : Out }) => cases.true;
  let false : Bool :=
    fun (Out : Type) (cases : { true : Out; false : Out }) => cases.false;
  let Option : fun (A : Type) -> Type :=
    fun (A : Type) =>
      fun (Out : Type) (_ : { some : fun (_ : A) -> Out; none : Out }) -> Out;
  let none : fun (A : Type) -> Option A :=
    fun (A : Type) (Out : Type)
    (cases : { some : fun (_ : A) -> Out; none : Out }) =>
      cases.none;
  let some : fun (A : Type) (a : A) -> Option A :=
    fun (A : Type) (a : A) (Out : Type)
    (cases : { some : fun (_ : A) -> Out; none : Out }) =>
      cases.some a;
  let Eq : Type := { T : Type; eq : fun (_ : T) (_ : T) -> Bool };
  let eq-bool :
        {
          T : Type [= Bool];
          eq :
            fun (_ :
                  fun (Out : Type) (_ : { true : Out; false : Out }) -> Out)
                (_ :
                  fun (Out : Type) (_ : { true : Out; false : Out }) -> Out)
                (Out : Type) (_ : { true : Out; false : Out }) -> Out
        }
  :=
    {
      T := #sing-intro;
      eq :=
        fun (x : fun (Out : Type) (_ : { true : Out; false : Out }) -> Out)
        (y : fun (Out : Type) (_ : { true : Out; false : Out }) -> Out) =>
          x Bool
            {
              true := y Bool { true := true; false := false };
              false := y Bool { true := false; false := true }
            }
    };
  let eq-option :
        fun (eq-a : Eq)
            -> {
              T : Type [= Option eq-a.T];
              eq :
                fun (_ :
                      fun (Out : Type)
                          (_ :
                            { some : fun (_ : eq-a.T) -> Out; none : Out })
                          -> Out)
                    (_ :
                      fun (Out : Type)
                          (_ :
                            { some : fun (_ : eq-a.T) -> Out; none : Out })
                          -> Out)
                    (Out : Type) (_ : { true : Out; false : Out }) -> Out
            }
  :=
    fun (eq-a : Eq) => {
      T := #sing-intro;
      eq :=
        fun
        (x :
          fun (Out : Type)
              (_ : { some : fun (_ : eq-a.T) -> Out; none : Out }) -> Out)
        (y :
          fun (Out : Type)
              (_ : { some : fun (_ : eq-a.T) -> Out; none : Out }) -> Out)
        =>
          x Bool
            {
              some :=
                fun (x : eq-a.T) =>
                  y Bool
                    {
                      some := fun (y : eq-a.T) => eq-a.eq x y;
                      none := false
                    };
              none :=
                y Bool { some := fun (_ : eq-a.T) => false; none := true }
            }
    };
  let Map : Type :=
    {
      Key : Type;
      Map : fun (_ : Type) -> Type;
      empty : fun (A : Type) -> Map A;
      add : fun (A : Type) (_ : Key) (_ : A) (_ : Map A) -> Map A;
      lookup : fun (A : Type) (_ : Key) (_ : Map A) -> Option A
    };
  let eq-map :
        fun (key : Eq)
            -> {
              Key : Type [= key.T];
              Map : fun (_ : Type) -> Type;
              empty : fun (A : Type) -> Map A;
              add : fun (A : Type) (_ : key.T) (_ : A) (_ : Map A) -> Map A;
              lookup :
                fun (A : Type) (_ : key.T) (_ : Map A) (Out : Type)
                    (_ : { some : fun (_ : A) -> Out; none : Out }) -> Out
            }
  :=
    fun (key : Eq) => {
      Key := #sing-intro;
      Map := fun (A : Type) => fun (_ : key.T) -> Option A;
      empty := fun (A : Type) (x : key.T) => none A;
      add :=
        fun (A : Type) (k : key.T) (v : A)
        (map :
          fun (_ : key.T) (Out : Type)
              (_ : { some : fun (_ : A) -> Out; none : Out }) -> Out)
        (x : key.T) =>
          key.eq x k (Option A) { true := some A v; false := map x };
      lookup :=
        fun (A : Type) (k : key.T)
        (map :
          fun (_ : key.T) (Out : Type)
              (_ : { some : fun (_ : A) -> Out; none : Out }) -> Out)
        =>
          map k
    };
  let empty : fun (key : Eq) (A : Type) -> (eq-map key).Map A :=
    fun (key : Eq) (A : Type) => (eq-map key).empty A;
  let add :
        fun (key : Eq) (A : Type) (_ : key.T) (_ : A)
            (_ : (eq-map key).Map A) -> (eq-map key).Map A
  := fun (key : Eq) (A : Type) => (eq-map key).add A;
  let lookup :
        fun (key : Eq) (A : Type) (_ : key.T) (_ : (eq-map key).Map A)
            -> Option A
  := fun (key : Eq) (A : Type) => (eq-map key).lookup A;
  Type
